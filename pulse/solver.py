import sys

import dolfin as df


class NonlinearProblem(df.NonlinearProblem):
    def __init__(
        self, J, F, bcs, output_matrix=False, output_matrix_path=".", verbose=False
    ):
        self.bilinear_form = J
        self.linear_form = F
        self.bcs = bcs
        self.output_matrix = output_matrix
        self.output_matrix_path = output_matrix_path
        self.verbose = verbose
        self.n = 0
        df.NonlinearProblem.__init__(self)

    def F(self, b, x):
        df.assemble(self.linear_form, tensor=b)
        for bc in self.bcs:
            bc.apply(b, x)

    def J(self, A, x):
        df.assemble(self.bilinear_form, tensor=A)
        for bc in self.bcs:
            bc.apply(A)

        if self.output_matrix:
            filename = "{}/J_{:04d}.mtx".format(self.output_matrix_path, self.n)
            with open(filename, "w") as f:
                mat = df.as_backend_type(A).mat()
                (num_rows, num_columns) = mat.size
                (ai, aj, av) = mat.getValuesCSR()
                num_nonzeros = len(av)
                f.write("%%MatrixMarket matrix coordinate real general\n")
                f.write("% Generated by {}\n".format(" ".join(sys.argv)))
                f.write("{} {} {}\n".format(num_rows, num_columns, num_nonzeros))
                for i in range(num_rows):
                    for k in range(ai[i], ai[i + 1]):
                        f.write("{} {} {}\n".format(i + 1, aj[k] + 1, av[k]))

            if self.verbose:
                print("Assembled matrix written to {}".format(filename))
            self.n = self.n + 1


class NewtonSolver(df.NewtonSolver):
    def __init__(
        self,
        mesh,
        newton_solver_rtol=1e-5,
        newton_solver_atol=1e-5,
        newton_solver_max_its=20,
        newton_solver_relaxation_parameter=1.0,
        krylov_solver="preonly",
        krylov_solver_rtol=None,
        krylov_solver_atol=None,
        krylov_solver_max_its=None,
        preconditioner="lu",
        pc_factor_mat_solver_type=None,
        mat_superlu_dist_equil=None,
        mat_superlu_dist_rowperm=None,
        mat_superlu_dist_colperm=None,
        mat_superlu_dist_parsymbfact=None,
        mat_superlu_dist_replacetinypivot=None,
        mat_superlu_dist_fact=None,
        mat_superlu_dist_iterrefine=None,
        mat_superlu_dist_statprint=None,
        pc_hypre_type=None,
        verbose=0,
    ):

        self.newton_solver_rtol = newton_solver_rtol
        self.newton_solver_atol = newton_solver_atol
        self.newton_solver_max_its = newton_solver_max_its
        self.newton_solver_relaxation_parameter = newton_solver_relaxation_parameter
        self.krylov_solver = krylov_solver
        self.krylov_solver_rtol = krylov_solver_rtol
        self.krylov_solver_atol = krylov_solver_atol
        self.krylov_solver_max_its = krylov_solver_max_its
        self.preconditioner = preconditioner
        self.pc_factor_mat_solver_type = pc_factor_mat_solver_type
        self.mat_superlu_dist_equil = mat_superlu_dist_equil
        self.mat_superlu_dist_rowperm = mat_superlu_dist_rowperm
        self.mat_superlu_dist_colperm = mat_superlu_dist_colperm
        self.mat_superlu_dist_parsymbfact = mat_superlu_dist_parsymbfact
        self.mat_superlu_dist_replacetinypivot = mat_superlu_dist_replacetinypivot
        self.mat_superlu_dist_fact = mat_superlu_dist_fact
        self.mat_superlu_dist_iterrefine = mat_superlu_dist_iterrefine
        self.mat_superlu_dist_statprint = mat_superlu_dist_statprint
        self.pc_hypre_type = pc_hypre_type
        self.verbose = verbose

        df.NewtonSolver.__init__(
            self, mesh.mpi_comm(), df.PETScKrylovSolver(), df.PETScFactory.instance()
        )

        self.parameters.update(
            {
                "error_on_nonconvergence": False,
                "relative_tolerance": self.newton_solver_rtol,
                "absolute_tolerance": self.newton_solver_atol,
                "maximum_iterations": self.newton_solver_max_its,
                "relaxation_parameter": self.newton_solver_relaxation_parameter,
            }
        )

    def solver_setup(self, A, P, problem, iteration):
        self.linear_solver().set_operator(A)
        df.PETScOptions.set("ksp_error_if_not_converged", False)
        if self.verbose > 2:
            df.PETScOptions.set("ksp_monitor")
            df.PETScOptions.set("log_view")
            df.PETScOptions.set("ksp_view")
            df.PETScOptions.set("pc_view")
        if self.krylov_solver:
            df.PETScOptions.set("ksp_type", self.krylov_solver)
        if self.krylov_solver_rtol:
            df.PETScOptions.set("ksp_rtol", self.krylov_solver_rtol)
        if self.krylov_solver_atol:
            df.PETScOptions.set("ksp_atol", self.krylov_solver_atol)
        if self.krylov_solver_max_its:
            df.PETScOptions.set("ksp_max_it", self.krylov_solver_max_its)
        df.PETScOptions.set("ksp_norm_type", "preconditioned")
        if self.krylov_solver_max_its:
            df.PETScOptions.set("ksp_gmres_restart", self.krylov_solver_max_its)
        if self.preconditioner:
            df.PETScOptions.set("pc_type", self.preconditioner)
        if self.pc_factor_mat_solver_type:
            df.PETScOptions.set(
                "pc_factor_mat_solver_type", self.pc_factor_mat_solver_type
            )
        if self.mat_superlu_dist_equil:
            df.PETScOptions.set("mat_superlu_dist_equil", self.mat_superlu_dist_equil)
        if self.mat_superlu_dist_rowperm:
            df.PETScOptions.set(
                "mat_superlu_dist_rowperm", self.mat_superlu_dist_rowperm
            )
        if self.mat_superlu_dist_colperm:
            df.PETScOptions.set(
                "mat_superlu_dist_colperm", self.mat_superlu_dist_colperm
            )
        if self.mat_superlu_dist_parsymbfact:
            df.PETScOptions.set(
                "mat_superlu_dist_parsymbfact", self.mat_superlu_dist_parsymbfact
            )
        if self.mat_superlu_dist_replacetinypivot:
            df.PETScOptions.set(
                "mat_superlu_dist_replacetinypivot",
                self.mat_superlu_dist_replacetinypivot,
            )
        if self.mat_superlu_dist_fact:
            df.PETScOptions.set("mat_superlu_dist_fact", self.mat_superlu_dist_fact)
        if self.mat_superlu_dist_iterrefine:
            df.PETScOptions.set(
                "mat_superlu_dist_iterrefine", self.mat_superlu_dist_iterrefine
            )
        if self.mat_superlu_dist_statprint:
            df.PETScOptions.set(
                "mat_superlu_dist_statprint", self.mat_superlu_dist_statprint
            )
        if self.pc_hypre_type:
            df.PETScOptions.set("pc_hypre_type", self.pc_hypre_type)
        self.linear_solver().set_from_options()
